# This module contains modules of error constants, from each constant an exception class will be generated.
# Each submodule will be created as a class; it will be used as an intermediate ancestor between the exception class
# and the application exception class.
# For example, where Application is the name of the application:
# module ApplicationError
#   module General
#     UNEXPECTED = "An error has occurred in the application. Please try again."
#   end
#   module Loggable
#     SERVICE_FAULT = "The response from the service cannot be processed. Please try again"
#   end
#   module Serious
#     BAD_PROBLEM = "The server is on fire, please call the fire department"
#   end
# end
#
# class FirstController < ApplicationController
#    def index
#      raise ApplicationException::ServiceFault # Will automatically be handled by the error handling gem with corresponding message.
#    end
#
#    def create
#      raise RuntimeError  # Will automatically be handled by error handling gem with UNEXPECTED message.
#    end
#
#    def update
#     raise ApplicationException::BadProblem
#     rescue ApplicationException::Parent => e  # Will rescue any of the exceptions generated by the plugin.
#       if(e.is_a? ApplicationException::Serious)  # Sub modules are created as ancestor classes of exceptions, useful for special casing.
#         call_lead_developer
#       end
#    end
# end
#
module RailsAppError

  module General
    # Default message for all general exceptions.
    # Unexpected exceptions (ones without specific exception classes) will be logged.
    UNEXPECTED = "An error has occurred with your last request. Please try again."
  end

  #Errors in this special module will be logged
  module Loggable
    HTML_MESSAGE = "A<br />message<br />with<br />html<br />!"
    LOG_THIS = "This is a really bad error. Tell someone!"
  end


  def self.include_all_of_own_modules
    constants.map { |c| const_get(c) }.select { |c| Module === c }.each { |c| include c }
  end

  include_all_of_own_modules
end
